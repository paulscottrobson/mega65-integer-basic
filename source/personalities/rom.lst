
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -c -D TARGET=2 -b -L rom.lst -o rom.bin ptest.asm
; Wed Jul 24 09:48:11 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					TARGET=2

;******  Processing input file: ptest.asm


;******  Processing file: personality_6502.asm

=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=4					EXTZPWork = 4								; Zero Page work for EXT
=$10					EXTZeroPage = $10 							; Zero Page allocated from here
=$1000					EXTNonZeroPage = $1000 						; Non-Zero page allocated from here
=$8000					EXTEndOfMemory = $8000 						; Memory ends.
=$f000					EXTScreen = $F000							; 1k screen RAM here
>c000	00 00					.word 	0 								; forces it to be a 16k ROM
>fffa	00 e0					.word 	EXTDummyInterrupt
>fffc	01 e0					.word 	EXTStartPersonalise
>fffe	00 e0					.word 	EXTDummyInterrupt
.e000					EXTDummyInterrupt:
.e000	40		rti			rti
.e001					EXTStartPersonalise:
.e001	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.e003	9a		txs			txs
.e004	20 7e e0	jsr $e07e		jsr 	EXTReset 						; reset video
.e007	20 34 e0	jsr $e034		jsr 	EXTClearScreen 					; clear screen
.e00a	4c c1 e1	jmp $e1c1		jmp 	Start 							; start main application
.e00d					EXTReadKey:
.e00d	ad 00 f8	lda $f800		lda 	$F800 								; read key
.e010	f0 07		beq $e019		beq 	_EXTExit
.e012	48		pha			pha 										; key pressed clear queue byte.
.e013	a9 00		lda #$00		lda 	#0
.e015	8d 00 f8	sta $f800		sta 	$F800
.e018	68		pla			pla
.e019					_EXTExit:
.e019	60		rts			rts
.e01a					EXTReadScreen:
.e01a	5a		phy			phy 										; save Y
.e01b	86 04		stx $04			stx 	EXTZPWork							; into EXTZPWork
.e01d	98		tya			tya
.e01e	09 f0		ora #$f0		ora 	#EXTScreen>>8 						; move into screen area
.e020	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.e022	a0 00		ldy #$00		ldy 	#0
.e024	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.e026	7a		ply			ply 										; restore Y and exit.
.e027	60		rts			rts
.e028					EXTWriteScreen:
.e028	5a		phy			phy
.e029	48		pha			pha
.e02a	20 1a e0	jsr $e01a		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.e02d	a0 00		ldy #$00		ldy 	#0
.e02f	68		pla			pla 										; restore and write.
.e030	91 04		sta ($04),y		sta 	(EXTZPWork),y
.e032	7a		ply			ply
.e033	60		rts			rts
.e034					EXTClearScreen:
.e034	48		pha			pha 										; save registers
.e035	da		phx			phx
.e036	a2 00		ldx #$00		ldx 	#0
.e038					_EXTCSLoop:
.e038	a9 20		lda #$20		lda 	#32
.e03a	9d 00 f0	sta $f000,x		sta 	EXTScreen+0,x
.e03d	9d 00 f1	sta $f100,x		sta 	EXTScreen+$100,x
.e040	9d 00 f2	sta $f200,x		sta 	EXTScreen+$200,x
.e043	9d 00 f3	sta $f300,x		sta 	EXTScreen+$300,x
.e046	e8		inx			inx
.e047	d0 ef		bne $e038		bne 	_EXTCSLoop
.e049	fa		plx			plx 										; restore
.e04a	68		pla			pla
.e04b	60		rts			rts
.e04c					EXTScrollDisplay:
.e04c	48		pha			pha 										; save registers
.e04d	5a		phy			phy
.e04e	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set pointer to screen
.e050	85 04		sta $04			sta 	EXTZPWork+0
.e052	a9 f0		lda #$f0		lda 	#EXTScreen >> 8
.e054	85 05		sta $05			sta 	EXTZPWork+1
.e056					_EXTScroll:
.e056	a0 28		ldy #$28		ldy 	#EXTWidth
.e058	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.e05a	a0 00		ldy #$00		ldy 	#0
.e05c	91 04		sta ($04),y		sta 	(EXTZPWork),y
.e05e	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.e060	d0 02		bne $e064		bne 	_EXTNoCarry
.e062	e6 05		inc $05			inc 	EXTZPWork+1
.e064					_EXTNoCarry:
.e064	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.e066	c9 c0		cmp #$c0		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) & $FF
.e068	d0 ec		bne $e056		bne 	_EXTScroll
.e06a	a5 05		lda $05			lda 	EXTZPWork+1
.e06c	c9 f3		cmp #$f3		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) >> 8
.e06e	d0 e6		bne $e056		bne 	_EXTScroll
.e070	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.e072					_EXTLastLine:
.e072	a9 20		lda #$20		lda 	#32
.e074	91 04		sta ($04),y		sta 	(EXTZPWork),y
.e076	c8		iny			iny
.e077	c0 28		cpy #$28		cpy 	#EXTWidth
.e079	d0 f7		bne $e072		bne 	_EXTLastLine
.e07b	7a		ply			ply 										; restore and exit.
.e07c	68		pla			pla
.e07d	60		rts			rts
.e07e					EXTReset:
.e07e	60		rts			rts

;******  Return to file: ptest.asm


;******  Processing file: personality_io.asm

=8					IOCursorX = 8 								; cursor position
=9					IOCursorY = 9
=10					IOLineLo = 10 								; line position.
=11					IOLineHi = 11
.e07f					IOInitialise:
.e07f	20 34 e0	jsr $e034			jsr 	EXTClearScreen 				; clear screen.
.e082	48		pha				pha
.e083	a9 00		lda #$00			lda 	#00 						; home cursor
.e085	85 08		sta $08				sta 	IOCursorX
.e087	85 09		sta $09				sta 	IOCursorY
.e089	68		pla				pla
.e08a	60		rts				rts
.e08b					IOPrintChar:
.e08b	48		pha				pha 								; save registers
.e08c	da		phx				phx
.e08d	5a		phy				phy
.e08e	29 7f		and #$7f			and 	#$7F 						; 7 bits only.
.e090	c9 0d		cmp #$0d			cmp 	#13 						; handle CR
.e092	f0 14		beq $e0a8			beq 	_IOPCCarriageReturn
.e094	c9 20		cmp #$20			cmp 	#$20 						; control character
.e096	90 30		bcc $e0c8			bcc 	_IOPControl
.e098	20 20 e1	jsr $e120			jsr	 	IOGetCursorXY 				; get cursor address in XY.
.e09b	29 3f		and #$3f			and 	#$3F 						; 6 bit PETSCII
.e09d	20 28 e0	jsr $e028			jsr 	EXTWriteScreen 				; write character at that position.
.e0a0	e6 08		inc $08				inc 	IOCursorX 					; increment cursor X
.e0a2	a5 08		lda $08				lda 	IOCursorX
.e0a4	c9 28		cmp #$28			cmp 	#EXTWidth 					; zero if at RHS
.e0a6	d0 1c		bne $e0c4			bne 	_IOPCExit
.e0a8					_IOPCCarriageReturn:
.e0a8	a9 00		lda #$00			lda 	#0							; LHS
.e0aa	85 08		sta $08				sta 	IOCursorX
.e0ac	e6 09		inc $09				inc 	IOCursorY 					; one down
.e0ae	a5 09		lda $09				lda 	IOCursorY 					; off the bottom ?
.e0b0	c9 19		cmp #$19			cmp 	#EXTHeight
.e0b2	d0 10		bne $e0c4			bne 	_IOPCExit
.e0b4	c6 09		dec $09				dec 	IOCursorY 					; back up and scroll
.e0b6	20 4c e0	jsr $e04c			jsr 	EXTScrollDisplay
.e0b9	80 09		bra $e0c4			bra 	_IOPCExit
.e0bb					_IOPCClear:
.e0bb	20 34 e0	jsr $e034			jsr 	EXTClearScreen
.e0be	a9 00		lda #$00			lda 	#0
.e0c0	85 08		sta $08				sta 	IOCursorX
.e0c2	85 09		sta $09				sta 	IOCursorY
.e0c4					_IOPCExit:
.e0c4	7a		ply				ply
.e0c5	fa		plx				plx
.e0c6	68		pla				pla
.e0c7	60		rts				rts
.e0c8					_IOPControl:
.e0c8	c9 1a		cmp #$1a			cmp 	#"Z"-64						; Ctrl-Z clear
.e0ca	f0 ef		beq $e0bb			beq 	_IOPCClear
.e0cc	c9 01		cmp #$01			cmp 	#"A"-64 					; Cursor movement.
.e0ce	f0 18		beq $e0e8			beq 	_IOPLeft
.e0d0	c9 04		cmp #$04			cmp 	#"D"-64
.e0d2	f0 1e		beq $e0f2			beq 	_IOPRight
.e0d4	c9 17		cmp #$17			cmp 	#"W"-64
.e0d6	f0 26		beq $e0fe			beq 	_IOPUp
.e0d8	c9 13		cmp #$13			cmp 	#"S"-64
.e0da	f0 2c		beq $e108			beq 	_IOPDown
.e0dc	c9 08		cmp #$08			cmp 	#8							; Backspace
.e0de	d0 e4		bne $e0c4			bne 	_IOPCExit
.e0e0	20 20 e1	jsr $e120			jsr	 	IOGetCursorXY 				; get cursor address in XY.
.e0e3	a9 20		lda #$20			lda 	#" "
.e0e5	20 28 e0	jsr $e028			jsr 	EXTWriteScreen 				; write space at that position.
.e0e8					_IOPLeft:
.e0e8	c6 08		dec $08				dec 	IOCursorX
.e0ea	10 d8		bpl $e0c4			bpl 	_IOPCExit
.e0ec	a9 27		lda #$27			lda 	#EXTWidth-1
.e0ee	85 08		sta $08				sta 	IOCursorX
.e0f0	80 d2		bra $e0c4			bra 	_IOPCExit
.e0f2					_IOPRight:
.e0f2	e6 08		inc $08				inc 	IOCursorX
.e0f4	a5 08		lda $08				lda 	IOCursorX
.e0f6	49 28		eor #$28			eor 	#EXTWidth
.e0f8	d0 ca		bne $e0c4			bne 	_IOPCExit
.e0fa	85 08		sta $08				sta 	IOCursorX
.e0fc	80 c6		bra $e0c4			bra 	_IOPCExit
.e0fe					_IOPUp:
.e0fe	c6 09		dec $09				dec 	IOCursorY
.e100	10 c2		bpl $e0c4			bpl 	_IOPCExit
.e102	a9 18		lda #$18			lda 	#EXTHeight-1
.e104	85 09		sta $09				sta 	IOCursorY
.e106	80 bc		bra $e0c4			bra 	_IOPCExit
.e108					_IOPDown:
.e108	e6 09		inc $09				inc 	IOCursorY
.e10a	a5 09		lda $09				lda 	IOCursorY
.e10c	49 19		eor #$19			eor 	#EXTHeight
.e10e	d0 b4		bne $e0c4			bne 	_IOPCExit
.e110	85 09		sta $09				sta 	IOCursorY
.e112	80 b0		bra $e0c4			bra 	_IOPCExit
.e114					IOUpperCase:
.e114	c9 61		cmp #$61			cmp 	#"a"
.e116	90 07		bcc $e11f			bcc 	_IOUCExit
.e118	c9 7b		cmp #$7b			cmp 	#"z"+1
.e11a	b0 03		bcs $e11f			bcs 	_IOUCExit
.e11c	38		sec				sec
.e11d	e9 20		sbc #$20			sbc 	#32
.e11f					_IOUCExit:
.e11f	60		rts				rts
.e120					IOGetCursorXY:
.e120	48		pha				pha
.e121	a5 09		lda $09				lda 	IOCursorY 					; multiply IOCursorY x 5
.e123	0a		asl a				asl		a
.e124	0a		asl a				asl		a 							; x 4, carry clear
.e125	65 09		adc $09				adc 	IOCursorY 					; so this will be 0..199 now
.e127	aa		tax				tax
.e128	8a		txa				txa 								; x 10
.e129	0a		asl a				asl 	a
.e12a	aa		tax				tax
.e12b	a9 00		lda #$00			lda 	#0
.e12d	2a		rol a				rol 	a
.e12e	a8		tay				tay
.e12f	8a		txa				txa 								; x 20
.e130	0a		asl a				asl 	a
.e131	aa		tax				tax
.e132	98		tya				tya
.e133	2a		rol a				rol 	a
.e134	a8		tay				tay
.e135	8a		txa				txa 								; x 40
.e136	0a		asl a				asl 	a
.e137	aa		tax				tax
.e138	98		tya				tya
.e139	2a		rol a				rol 	a
.e13a	a8		tay				tay
.e13b	8a		txa				txa 								; add X to that.
.e13c	18		clc				clc
.e13d	65 08		adc $08				adc 	IOCursorX
.e13f	aa		tax				tax
.e140	90 01		bcc $e143			bcc 	_IOGCXYExit
.e142	c8		iny				iny
.e143					_IOGCXYExit:
.e143	68		pla				pla
.e144	60		rts				rts
.e145					IOReadLine:
.e145	48		pha				pha
.e146	86 0a		stx $0a				stx		IOLineLo
.e148	84 0b		sty $0b				sty 	IOLineHi
.e14a					_IROLLoop:
.e14a	20 20 e1	jsr $e120			jsr	 	IOGetCursorXY 				; get cursor address in XY.
.e14d	20 1a e0	jsr $e01a			jsr 	EXTReadScreen 				; get character there.
.e150	48		pha				pha
.e151	a9 66		lda #$66			lda 	#102 						; write cursor character there
.e153	20 28 e0	jsr $e028			jsr		EXTWriteScreen
.e156					_IROLWaitKey:
.e156	20 0d e0	jsr $e00d			jsr 	EXTReadKey
.e159	09 00		ora #$00			ora 	#0
.e15b	f0 f9		beq $e156			beq 	_IROLWaitKey
.e15d	20 14 e1	jsr $e114			jsr 	IOUpperCase 				; capitalise
.e160	aa		tax				tax 								; save in X
.e161	68		pla				pla 								; restore old
.e162	da		phx				phx 								; save new character.
.e163	20 20 e1	jsr $e120			jsr	 	IOGetCursorXY 				; get cursor address in XY.
.e166	20 28 e0	jsr $e028			jsr 	EXTWriteScreen 				; write out.
.e169	68		pla				pla 								; restore old
.e16a	c9 0d		cmp #$0d			cmp 	#13
.e16c	f0 05		beq $e173			beq 	_IROLExit 					; exit if CR
.e16e	20 8b e0	jsr $e08b			jsr 	IOPrintChar 				; print it.
.e171	80 d7		bra $e14a			bra 	_IROLLoop
.e173					_IROLExit:
.e173	a9 00		lda #$00			lda 	#0 							; go to start of line.
.e175	85 08		sta $08				sta 	IOCursorX
.e177	a0 00		ldy #$00			ldy 	#0 							; position
.e179					_IROLCopy:
.e179	5a		phy				phy 								; save position
.e17a	20 20 e1	jsr $e120			jsr 	IOGetCursorXY 				; get cursor position.
.e17d	20 1a e0	jsr $e01a			jsr 	EXTReadScreen 				; read screen
.e180	7a		ply				ply 								; get position back
.e181	49 20		eor #$20			eor 	#$20
.e183	18		clc				clc
.e184	69 20		adc #$20			adc 	#$20
.e186	91 0a		sta ($0a),y			sta 	(IOLineLo),y 				; save in buffer.
.e188	e6 08		inc $08				inc 	IOCursorX 					; cursor right
.e18a	c8		iny				iny 								; bump pointer
.e18b	c0 28		cpy #$28			cpy 	#EXTWidth 					; not done full line.
.e18d	d0 ea		bne $e179			bne 	_IROLCopy
.e18f	a9 0d		lda #$0d			lda 	#13 						; carriage return
.e191	20 8b e0	jsr $e08b			jsr 	IOPrintChar
.e194	a0 28		ldy #$28			ldy 	#EXTWidth 					; trim trailing spaces
.e196					_IROLTrim:
.e196	88		dey				dey
.e197	30 06		bmi $e19f			bmi 	_IROLFound
.e199	b1 0a		lda ($0a),y			lda 	(IOLineLo),y
.e19b	c9 20		cmp #$20			cmp 	#32
.e19d	f0 f7		beq $e196			beq 	_IROLTrim
.e19f					_IROLFound:
.e19f	c8		iny				iny
.e1a0	a9 00		lda #$00			lda 	#0 							; make it ASCIIZ
.e1a2	91 0a		sta ($0a),y			sta 	(IOLineLo),y
.e1a4	a6 0a		ldx $0a				ldx 	IOLineLo
.e1a6	a4 0b		ldy $0b				ldy 	IOLineHi
.e1a8	68		pla				pla
.e1a9	60		rts				rts
.e1aa					IOPrintString:
.e1aa	48		pha				pha
.e1ab	86 0a		stx $0a				stx 	IOLineLo
.e1ad	84 0b		sty $0b				sty 	IOLineHi
.e1af	a0 00		ldy #$00			ldy 	#0
.e1b1					_IOPSLoop:
.e1b1	b1 0a		lda ($0a),y			lda 	(IOLineLo),y
.e1b3	f0 06		beq $e1bb			beq 	_IOPSExit
.e1b5	20 8b e0	jsr $e08b			jsr 	IOPrintChar
.e1b8	c8		iny				iny
.e1b9	80 f6		bra $e1b1			bra 	_IOPSLoop
.e1bb					_IOPSExit
.e1bb	a6 0a		ldx $0a				ldx 	IOLineLo
.e1bd	a4 0b		ldy $0b				ldy 	IOLineHi
.e1bf	68		pla				pla
.e1c0	60		rts				rts

;******  Return to file: ptest.asm

.e1c1					Start:
.e1c1	20 7f e0	jsr $e07f		jsr 	IOInitialise
.e1c4	a2 d5		ldx #$d5		ldx 	#St1 & 255
.e1c6	a0 e1		ldy #$e1		ldy 	#St1 >> 8
.e1c8	20 aa e1	jsr $e1aa		jsr 	IOPrintString
.e1cb					Loop:
.e1cb	a2 80		ldx #$80		ldx 	#$80
.e1cd	a0 00		ldy #$00		ldy 	#$00
.e1cf	20 45 e1	jsr $e145		jsr		IOReadLine
>e1d2	03					.byte 	3
.e1d3	80 f6		bra $e1cb		bra 	Loop
>e1d5	37 31 36 37 20 42 59 54		St1:.text 	"7167 BYTES FREE",0
>e1dd	45 53 20 46 52 45 45 00

;******  End of listing
